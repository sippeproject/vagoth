#!/usr/bin/python

from vagoth.manager import get_manager
from vagoth.transaction import Transaction
from vagoth.exceptions import NodeNotFoundException
import argparse
import json
import getpass
import logging
import sys

# log to standard output
ch = logging.StreamHandler()
logging.getLogger().addHandler(ch)
logging.getLogger().setLevel(logging.INFO)

def pprint(dictionary):
    print(json.dumps(dictionary, indent=2))

manager = None

p_global = argparse.ArgumentParser(add_help=True,
    formatter_class=argparse.RawTextHelpFormatter)
p_global.add_argument("-v", "--verbose", action='store_true')
p_global_subs = p_global.add_subparsers(title="subcommands", description="""Commands to manage VMs on Vagoth

A typical lifecycle is:
  * new <vm_name> [k1=v1 ...] (provisioner adds new VM to cluster)
  * start <vm_name> (allocator assigns VM to node and starts it)
  * shutdown <vm_name> (polite shutdown of VM)
  * undefine <vm_name> (unassign VM from current HV)
  * deprovision <vm_name> (wipe VM data, and remove from current HV)
  * delete <vm_name> (provisioner removes VM from cluster)
""")

# helper function to create a subcommand with argparse
def make_subcommand(command, helptext, function):
    global p_global_subs
    parser = p_global_subs.add_parser(command, help=helptext)
    parser.set_defaults(func=function, _command=command)
    return parser

def cmd_list(args):
    global manager
    for node in sorted(manager.get_nodes()):
        if args.type and node.node_type != args.type:
            continue
        if args.tag and args.tag not in node.tags:
            continue
        if args.uniquekey and args.uniquekey not in node.unique_keys:
            continue
        parent = node.parent
        assignment = parent and parent.name or ""
        print("{0} [{1}] type={2} parent={3} tags={4}".format(
            node.name, node.state, node.node_type,
            assignment, ",".join(node.tags)))
p_list = make_subcommand("list", "List all VMs", cmd_list)
p_list.add_argument("--tag", type=str, help="Limit by tag", default=None)
p_list.add_argument("--type", type=str, help="Limit by type", default=None)
p_list.add_argument("--uniquekey", type=str, help="Limit by unique key", default=None)

def print_node_and_children(node, parents, indent=0):
    global manager
    print("  "*indent+"{0} [{1}] type={2}".format(node.name, node.state, node.node_type))
    children = parents.get(node.node_id, [])
    for child in children:
        print_node_and_children(child, parents, indent+1)

def cmd_tree(args):
    global manager
    roots = []
    parents = {}
    nodes = manager.get_nodes()
    for node in nodes:
        if node.parent is None:
            roots.append(node)
        else:
            if node.parent.node_id in parents:
                parents[node.parent.node_id].append(node)
            else:
                parents[node.parent.node_id] = [node,]
    for node in sorted(roots):
        print_node_and_children(node, parents, indent=0)
p_tree = make_subcommand("tree", "List all VMs as a tree", cmd_tree)

def cmd_listvm(args):
    global manager
    for node in sorted(manager.get_nodes_with_type("vm")):
      parent = node.parent
      assignment = parent and parent.name or ""
      print("{0} [{1}] type={2} parent={3}".format(node.name, node.state, node.node_type, assignment))
p_listvm = make_subcommand("listvm", "List all VMs (type=vm)", cmd_listvm)

def cmd_listhv(args):
    global manager
    for node in manager.get_nodes_with_type('hv'):
        print("{0} [{1}]".format(node.name, node.state))
p_listhv = make_subcommand("listhv", "List all hypervisor nodes (type=hv)", cmd_listhv)

def status(command, node_name, msg):
    print("{0}: {1} ({2})".format(command, msg, node_name))

def fail(command, node_name, msg, exit_code=1):
    status(command, node_name, msg)
    sys.exit(exit_code)

def cmd_start(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    try:
        vm.start()
        status("start", args.vm_name, "OK")
    except AttributeError:
        fail("start", args.vm_name, "unsupported action")
        print("start: unsupported action ({0})".format(args.vm_name))
p_start = make_subcommand("start", "Start a VM (& allocate if required)", cmd_start)
p_start.add_argument("vm_name", type=str, help="Name of VM")

def cmd_stop(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    try:
        vm.stop()
        status("stop", args.vm_name, "OK")
    except AttributeError:
        fail("stop", args.vm_name, "unsupported action")
p_stop = make_subcommand("stop", "Stop a VM", cmd_stop)
p_stop.add_argument("vm_name", type=str, help="Name of VM")

def cmd_shutdown(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    try:
        vm.shutdown()
        status("shutdown", vm_name, "OK")
    except:
        fail("shutdown", vm_name, "unsupported action")
p_shutdown = make_subcommand("shutdown", "Politely stop a VM", cmd_shutdown)
p_shutdown.add_argument("vm_name", type=str, help="Name of VM")

def cmd_info(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    print "# definition:"
    pprint(vm.definition)
    print "# metadata:"
    pprint(vm.metadata)
    print "# state:"
    pprint(vm.state)
p_info = make_subcommand("info", "Display information about a VM", cmd_info)
p_info.add_argument("vm_name", type=str, help="Name of VM")

def cmd_undefine(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    node = vm.parent
    vm.state = 'unassigned'
    if node:
        try:
            vm.undefine()
            status("undefine", args.vm_name, "OK")
        except AttributeError:
            fail("undefine", args.vm_name, "unsupported action")
    else:
        fail("undefine", args.vm_name, "vm has no parent node")
p_undefine = make_subcommand("undefine", "Undefine VM from a node", cmd_undefine)
p_undefine.add_argument("vm_name", type=str, help="Name of VM")

def cmd_define(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    try:
        vm.define()
        status("define", args.vm_name, "OK")
    except AttributeError:
        fail("define", args.vm_name, "unsupported action")
p_define = make_subcommand("define", "Define a VM on a node", cmd_define)
p_define.add_argument("vm_name", type=str, help="Name of VM")
p_define.add_argument("-H", "--hint", help="Optional hint for the VM allocation plugin")

def cmd_provision(args):
    global manager
    vm = manager.get_node(args.vm_name)
    try:
        vm.provision()
        print("provision: OK ({0})".format(args.vm_name))
    except AttributeError:
        print("provision: unsupported action ({0})".format(args.vm_name))
p_provision = make_subcommand("provision", "Provision a VM on a node (re-init first)", cmd_provision)
p_provision.add_argument("vm_name", type=str, help="Name of VM")

def cmd_deprovision(args):
    global manager
    vm = manager.get_node(args.vm_name)
    if vm.parent:
        try:
            vm.deprovision()
            print("deprovision: OK ({0})".format(args.vm_name))
        except AttributeError:
            print("deprovision: unsupported action ({0})".format(args.vm_name))
p_deprovision = make_subcommand("deprovision", "Deprovision a VM on a node", cmd_deprovision)
p_deprovision.add_argument("vm_name", type=str, help="Name of VM")

def cmd_new(args):
    global manager
    definition = {}
    for arg in args.kwargs:
        k,v = arg.split("=",1)
        definition[k] = v
    manager.provisioner.provision(args.node_id,
        node_type=args.node_type,
        definition=definition)
p_new = make_subcommand("new", "Create a new VM in the cluster", cmd_new)
p_new.add_argument("node_id", type=str, help="Node ID")
p_new.add_argument("node_type", type=str, help="Node Type")
p_new.add_argument("kwargs", nargs="*", help="key=value arguments")

def cmd_delete(args):
    global manager
    vm = manager.get_node_by_name(args.vm_name)
    manager.provisioner.deprovision(vm)
p_delete = make_subcommand("delete", "Delete a node from the cluster (must not be assigned)", cmd_delete)
p_delete.add_argument("vm_name", type=str, help="Name of VM")

def cmd_rename(args):
    global manager
    node = manager.get_node_by_name(args.old_name)
    manager.registry.set_node(node.node_id, node_name=args.new_name)
p_rename = make_subcommand("rename", "Rename a node (nice name only)", cmd_rename)
p_rename.add_argument("old_name", type=str, help="Current name of VM")
p_rename.add_argument("new_name", type=str, help="New name of VM")
    

def cmd_poll(args):
    global manager
    manager.action("vm_poll")
p_poll = make_subcommand("poll", "Poll cluster for status", cmd_poll)

if __name__ == '__main__':
    args = p_global.parse_args()
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    with Transaction(getpass.getuser()):
        try:
            manager = get_manager()
            try:
                args.func(args)
            except NodeNotFoundException as e:
                if hasattr(args, "vm_name"):
                    fail(args._command, args.vm_name, "node not found")
                else:
                    raise
        finally:
            manager.cleanup()
